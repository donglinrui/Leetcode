### 二叉树

#### 递归遍历方法

例：后序遍历

```java
  public static void postOrderTraveral(TreeNode node){
        if(node == null){
            return;
        }
        postOrderTraveral(node.leftChild);
        postOrderTraveral(node.rightChild);
        System.out.print(node.data+" ");
    }
```

#### 非递归遍历

https://blog.csdn.net/z_ryan/article/details/80854233

#### 深度优先遍历和广度广度遍历：

1、深度优先遍历常用的数据结构为栈，广度优先遍历常用的数据结构为队列
2、深度优先遍历的思想是从上至下，对每一个分支一直往下一层遍历直到这个分支结束，然后返回上一层，对上一层的右子树这个分支继续深搜，直到一整棵树完全遍历，因此深搜的步骤符合栈后进先出的特点
广度优先遍历的思想是从左至右，对树的每一层所有结点依次遍历，当一层的结点遍历完全后，对下一层开始遍历，而下一层结点又恰好是上一层的子结点。因此广搜的步骤符合队列先进先出的思想。
3、关于二叉树的深度优先搜索
则又有三种遍历方法
先序遍历：对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。
中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。
后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。
除了利用栈以外，深度优先搜索也可以使用递归的方法。’
4、深度优先搜索算法：不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。
广度优先搜索算法：保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。

#### 二叉树深度计算

二叉树深度 = Max（左节点深度，右节点深度）

### 动态规划问题

按照定义，**动态规划**是把一个大问题拆解成一堆小问题，这个本身没啥问题，但是我觉得的这个不是**动态规划**的核心思想，或者说，一个”大问题“之所以能用”**动态规划**“解决，并不是因为它能拆解成一堆小问题，事实上啥大问题都能拆解成小问题...

取决于该问题是否能用动态规划解决的是这些”小问题“会不会被被重复调用。